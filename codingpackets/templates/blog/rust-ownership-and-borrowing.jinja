{% extends "_layouts/blog.jinja" %}

{% block page_content %}

<h3>Intro</h3>
<p>
</p>


<h3>Rules</h3>

<h3>TODO: Investigate</h3>
<ul>
  <li>Data Races</li>
  <li>Deadlocks</li>
  <li>Race Conditions</li>
</ul>

<h4>3 Causes of Data Races</h4>
<ul>
  <li>Two or more pointers access the same data at the same time.</li>
  <li>At least one of the pointers is being used to write to the data.</li>
  <li>There's no mechanism being used to synchronize access to the data.</li>
</ul>

<h4>3 Rules of Ownership</h4>
<ul>
  <li>Each value in Rust has a variable that's called its owner.</li>
  <li>There can only be one owner at a time.</li>
  <li>When the owner goes out of scope, the value will be dropped.</li>
</ul>

<h4>2 Rules of References</h4>
<ul>
  <li>At any given time, you can have either one mutable reference or any number of immutable references.</li>
  <li>References must always be valid.</li>
</ul>

<h3>Runtime</h3>
<p>
  Executing async code requires an async runtime.  
</p>

<h3>Await</h3>
<p>
  Signal to the scheduler that a task requires some amount of waiting.
  Awaiting someting always returns a future.
</p>

<h3>Futures</h3>
<p>
  Returned by an asynchronous operation. Created by async blocks or 
  implementing the Future trait
</p>

<h3>Streams</h3>
<p>
  Iterators in async land that are used on sequences of the same type.
</p>

<h3>Outro</h3>
<p>
</p>

{% endblock page_content %}